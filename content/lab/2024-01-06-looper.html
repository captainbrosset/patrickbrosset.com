<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>looper</title>
  <style>
    body {
      font-family: system-ui;
      font-size: 1rem;
      padding: 1rem;
      margin: 0;
    }

    h1,
    p {
      margin: 0;
    }

    header {
      margin-block-end: 1rem;
    }

    input,
    button {
      font-family: inherit;
      font-size: inherit;
    }

    button {
      border: 2px solid #0003;
      background: aliceblue;
      padding: .5rem;
    }

    #add-track {
      aspect-ratio: 1;
      place-self: center;
      border-radius: 50%;
      background: aliceblue;
      padding: .5rem;
      border: 2px solid #000;
    }

    #looper {
      border: 2px solid black;
      border-radius: 1rem;
      padding: 1rem;
      background: #eee;
      box-shadow: 0 0 1rem 0 #0005;
      min-width: 12rem;
    }

    .buttons {
      display: grid;
      gap: 1rem;
      grid-auto-flow: column;
      justify-content: center;
      margin-block-end: 1rem;
    }

    .buttons button {
      border-radius: .25rem;
    }

    .tracks {
      display: grid;
      gap: .5rem;
      grid-template-columns: repeat(auto-fill, 12rem);
      justify-content: center;
    }

    .track {
      padding: 1rem;
      border: 2px solid black;
      border-radius: .5rem;
      display: grid;
      gap: .5rem;
      grid-template-columns: repeat(3, 1fr);
      justify-items: center;
      counter-increment: track-nb;
      background-image: linear-gradient(to right, red 100%, transparent 0);
      background-repeat: no-repeat;
      background-size: 0 1rem;
      background-position: left bottom;
      background-color: white;
    }

    .track::before {
      content: counter(track-nb);
      border-radius: 50%;
      background: aliceblue;
      font-weight: bold;
      display: grid;
      place-content: center;
      grid-column: 2;
      border: 2px solid #0003;
      width: min-content;
      padding: .5rem;
      aspect-ratio: 1;
    }

    .track.has-buffer::before {
      background: #00ff25;
    }

    .track .clear,
    .track .mute {
      padding: .5rem;
      border-radius: 50%;
      aspect-ratio: 1;
    }

    .track .mute {
      width: min-content;
      grid-column: 1;
      grid-row: 1;
    }

    .track .record {
      color: #39a0b8;
      border-radius: 50%;
      width: 10rem;
      aspect-ratio: 1;
      font-size: 2rem;
      background-image: radial-gradient(#9fc8ec 0 50%, black 50% calc(50% + 2px), transparent 0), repeating-conic-gradient(#0003 0 2deg, transparent 2deg 15deg);
      border: 2px solid black;
      grid-column: span 3;
    }

    .track .gain {
      rotate: -90deg;
      width: 7rem;
      height: 7rem;
      grid-column: span 3;
    }

    .track.is-recording .record {
      background-color: rgb(237, 66, 66);
    }

    .track.has-buffer .record {
      background-color: #00ff25;
    }

    .track.master {
      background-color: #b4bed2;
    }
  </style>
</head>

<body>
  <header>
    <h1>Looper</h1>
    <p>A simple multi-track audio looper by <a href="https://patrickbrosset.com">Patrick Brosset</a>.</p>
  </header>
  <main id="looper">
    <div class="buttons">
      <button id="start" title="Start the looper">Start</button>
      <button id="mute-all" title="Mute all tracks" hidden>üîá</button>
      <button id="clear-all" title="Clear all tracks" hidden>üóëÔ∏è</button>
    </div>
    <div class="tracks">
      <button id="add-track" hidden title="Add a new track">‚ûï</button>
    </div>
  </main>


  <script>
    const startLooperButton = document.querySelector("#start");
    const muteAllButton = document.querySelector("#mute-all");
    const addTrackButton = document.querySelector("#add-track");
    const clearAllButton = document.querySelector("#clear-all");
    const tracksEl = document.querySelector(".tracks");

    const DEFAULT_GAIN_VALUE = 0.5;

    // How many nodes to schedule at once per track.
    // When a track's buffer is ready, we schedule a bunch
    // of nodes in the future to avoid scheduling on a less
    // ideal time.
    // But only schedule a few at a time to avoid blocking.
    const AUDIO_NODE_BATCH_NUMBER = 50;

    let audioContext = null;
    let micRecorder = null;
    let tracks = [];
    let isAllMuted = false;
    const initTrackNb = 3;
    let masterTrack = null;

    class Track {
      constructor(parentEl, micRecorder, masterTrack) {
        this.parentEl = parentEl;
        this.micRecorder = micRecorder;
        this.isMaster = !masterTrack;
        this.masterTrack = masterTrack;

        this.createDom();
        this.parentEl.insertBefore(this.el, addTrackButton);
        this.el.classList.toggle("master", this.isMaster);

        this.buffer = null;
        this.state = 0;
        this.isMuted = false;
        this.playAnimation = null;
        this.recordStartTime = 0;
        this.gainValue = DEFAULT_GAIN_VALUE;
        this.nodeCreationInterval = null;

        this.scheduledNodes = [];

        this.muteButton.addEventListener("click", () => {
          this.toggleMute();
        });

        if (this.isMaster) {
          this.clearButton.setAttribute("disabled", true);
        } else {
          this.clearButton.addEventListener("click", () => {
            this.clear();
          });
        }

        this.recordButton.addEventListener("click", () => {
          this.handleStartStopRecord();
        });

        this.gainRangeEl.addEventListener("input", () => {
          this.gainValue = parseFloat(this.gainRangeEl.value);

          if (this.gainValue === 0) {
            this.mute();
          } else {
            this.unmute();
          }
        });
      }

      createDom() {
        this.el = document.createElement("section");
        this.el.classList.add("track");

        this.muteButton = document.createElement("button");
        this.muteButton.classList.add("mute");
        this.muteButton.textContent = "üîâ";
        this.muteButton.title = "Mute/Unmute";
        this.el.appendChild(this.muteButton);

        this.clearButton = document.createElement("button");
        this.clearButton.classList.add("clear");
        this.clearButton.textContent = "üóëÔ∏è";
        this.clearButton.title = "Clear track";
        this.el.appendChild(this.clearButton);

        this.gainRangeEl = document.createElement("input");
        this.gainRangeEl.classList.add("gain");
        this.gainRangeEl.type = "range";
        this.gainRangeEl.min = 0;
        this.gainRangeEl.max = 1;
        this.gainRangeEl.step = 0.01;
        this.gainRangeEl.value = DEFAULT_GAIN_VALUE;
        this.el.appendChild(this.gainRangeEl);

        this.recordButton = document.createElement("button");
        this.recordButton.classList.add("record");
        this.recordButton.textContent = "‚è∫Ô∏è/‚ñ∂Ô∏è";
        this.recordButton.title = "Record/Play";
        this.el.appendChild(this.recordButton);
      }

      toggleMute() {
        if (this.isMuted) {
          this.unmute();
        } else {
          this.mute();
        }
      }

      mute() {
        this.scheduledNodes.forEach(({ gainNode }) => {
          gainNode.gain.value = 0;
        });
        this.muteButton.textContent = "üîá";

        this.isMuted = true;
        this.el.classList.add("muted");

        this.gainRangeEl.value = 0;
      }

      unmute() {
        // If we're unmuting but our last gain value was 0,
        // go back to 1.
        if (this.gainValue === 0) {
          this.gainValue = DEFAULT_GAIN_VALUE;
        }

        if (this.gainValue < 0.33) {
          this.muteButton.textContent = "üîà";
        } else if (this.gainValue < 0.66) {
          this.muteButton.textContent = "üîâ";
        } else {
          this.muteButton.textContent = "üîä";
        }

        this.isMuted = false;
        this.el.classList.remove("muted");

        this.gainRangeEl.value = this.gainValue;
        this.scheduledNodes.forEach(({ gainNode }) => {
          gainNode.gain.value = this.gainValue;
        });
      }

      clear() {
        this.unmute();

        clearInterval(this.nodeCreationInterval);
        this.state = 0;
        this.buffer = null;
        this.el.classList.remove("has-buffer");
        this.gainRangeEl.value = DEFAULT_GAIN_VALUE;

        if (this.playAnimation) {
          this.playAnimation.cancel();
          this.playAnimation = null;
        }
        
        this.deleteNodes(this.scheduledNodes);
        this.scheduledNodes = [];
      }

      deleteNodes(nodes) {
        for (const { audioNode, gainNode } of nodes) {
          audioNode.stop();
          audioNode.disconnect();
          gainNode.disconnect();
        }
      }

      handleStartStopRecord() {
        if (!this.state) {
          // Set the record start time right when the record
          // button is pressed. This is so that we can schedule
          // the audio nodes in the future at exactly the right
          // time.
          this.recordStartTime = audioContext.currentTime;
          this.state = 1;

          this.micRecorder.onBufferReady = buffer => {
            this.el.classList.add("has-buffer");
            this.el.classList.remove("is-recording");
            if (!this.isMaster) {
              this.clearButton.removeAttribute("disabled");
            }
            this.buffer = buffer;
            this._go();
          };

          this.micRecorder.startRecording();
          this.el.classList.add("is-recording");
          this.clearButton.setAttribute("disabled", true);
        } else if (this.state === 1) {
          this.micRecorder.stopRecording();
          this.state = 2;
        } else if (this.state === 2) {
          this.clear();
          this.handleStartStopRecord();
        }
      }

      _go() {
        if (!this.buffer) {
          return;
        }

        const masterDuration = this.isMaster
          ? this.buffer.duration
          : this.masterTrack.buffer.duration;

        const now = audioContext.currentTime;
        let lastIndex = 0;

        const scheduleABatchOfNodes = () => {
          for (let i = 0; i < AUDIO_NODE_BATCH_NUMBER; i++) {
            const index = lastIndex + i;

            const when = this.isMaster
              ? now + index * masterDuration
              : this.recordStartTime + index * masterDuration;

            if (when < now) {
              continue;
            }

            this.refreshAudioNodes();
            this.scheduleNext(when);
          }
          
          if (lastIndex > AUDIO_NODE_BATCH_NUMBER) {
            this.deleteNodes(this.scheduledNodes.splice(0, AUDIO_NODE_BATCH_NUMBER));
          }
          
          lastIndex += AUDIO_NODE_BATCH_NUMBER;
        }
        scheduleABatchOfNodes();
        // Schedule new batches of nodes when we get close to the
        // end of the current batch.
        this.nodeCreationInterval = setInterval(scheduleABatchOfNodes, (AUDIO_NODE_BATCH_NUMBER - 1) * masterDuration * 1000);

        this.animateTrackPlayHead();
      }

      refreshAudioNodes() {
        const audioNode = audioContext.createBufferSource();
        audioNode.buffer = this.buffer;

        const gainNode = audioContext.createGain();
        gainNode.gain.value = this.isMuted ? 0 : this.gainValue;
        audioNode.connect(gainNode);

        gainNode.connect(audioContext.destination);

        this.scheduledNodes.push({ audioNode, gainNode });
      }

      scheduleNext(when) {
        this.scheduledNodes[this.scheduledNodes.length - 1].audioNode.start(when);
      }

      animateTrackPlayHead() {
        if (this.playAnimation) {
          return;
        }

        const duration = this.isMaster ? this.buffer.duration : this.masterTrack.buffer.duration;

        this.playAnimation = this.el.animate([
          { backgroundSize: "0 1rem" },
          { backgroundSize: "100% 1rem" },
        ], {
          duration: duration * 1000,
          iterations: Infinity
        });
      }
    }

    class MicRecorder {
      constructor() {
        this.stream = null;
        this.mediaRecorder = null;
        this.isRecording = false;
        this.recordedChunks = [];
      }

      async setup() {
        this.stream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: {
            echoCancellation: false,
            autoGainControl: false,
            noiseSuppression: false,
            latency: 0
          }
        });
      }

      // Call this to start recording.
      startRecording() {
        if (this.isRecording) {
          return;
        }

        this.mediaRecorder = new MediaRecorder(this.stream);

        this.mediaRecorder.ondataavailable = e => {
          this.recordedChunks.push(e.data);
        };

        this.mediaRecorder.onstart = e => { };

        this.mediaRecorder.onstop = async e => {
          const blob = new Blob(this.recordedChunks, { type: "audio/mp4" });
          const arrayBuffer = await blob.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          this.onBufferReady(audioBuffer);
        };

        this.recordedChunks = [];
        this.isRecording = true;
        this.mediaRecorder.start();
      }

      // Call this to stop recording.
      stopRecording() {
        if (!this.isRecording) {
          return;
        }

        this.isRecording = false;
        this.mediaRecorder.stop();
      }

      // Override this to get the newly recorded buffer.
      onBufferReady() { }
    }

    function clearAll() {
      tracks.forEach(track => {
        track.unmute();
        track.clear();
      });
    }

    function muteAll() {
      isAllMuted = !isAllMuted;

      tracks.forEach(track => {
        if (isAllMuted) {
          track.mute();
          muteAllButton.textContent = "üîà";
        } else {
          track.unmute();
          muteAllButton.textContent = "üîá";
        }
      });
    }

    function addTrack() {
      const track = new Track(tracksEl, micRecorder, masterTrack);
      tracks.push(track);
    }

    async function start() {
      clearAll();
      tracks = [];
      masterTrack = null;

      tracksEl.querySelectorAll(".track").forEach(trackEl => trackEl.remove());

      // Create the audio context.
      if (!audioContext) {
        audioContext = new AudioContext();
      }

      // Initialize the mic recorder.
      if (!micRecorder) {
        micRecorder = new MicRecorder();
        await micRecorder.setup();
      }

      // Create the master track.
      masterTrack = new Track(tracksEl, micRecorder);
      tracks.push(masterTrack);

      // Create some more tracks.
      for (let i = 0; i < initTrackNb; i++) {
        addTrack();
      }

      // Show the main buttons.
      muteAllButton.hidden = false;
      addTrackButton.hidden = false;
      clearAllButton.hidden = false;

      startLooperButton.textContent = "Restart";
    }

    clearAllButton.addEventListener("click", clearAll);
    muteAllButton.addEventListener("click", muteAll);
    addTrackButton.addEventListener("click", addTrack);
    startLooperButton.addEventListener('click', start);
  </script>
</body>

</html>